# 非同期実行.md — Pythonにおける「非同期」とは？（大元ガイド）

> **このファイルの目的**
> - 「非同期とは何か」を **1枚で俯瞰**できるようにする
> - Python（特に `asyncio`）での非同期が、**何を解決し／何を解決しないか**を明確にする
> - 後続の詳細ドキュメント（スレッド/プロセス/オフロード、Semaphore、例外処理、Queue設計など）へ **分岐できる**“玄関”を作る

---

## 目次

1. 非同期とは？（最短定義）
2. 同期 / 非同期 / 並行 / 並列 の違い
3. なぜ非同期が必要？（問題→解決）
4. Pythonにおける非同期（`asyncio`）の中核概念
5. 「await」＝“譲る”という発想
6. 非同期でよくある勘違い（重要）
7. 実務での典型パターン（ポーリング/ジョブ実行）
8. よくある落とし穴と対策（超概要）
9. 次に読むべき分割ドキュメント案（構成案）

---

## 1. 非同期とは？（最短定義）

**非同期（asynchronous）**とは、
> 「ある処理が完了するまで待ち続けず、待っている間に別の処理を進め、完了したら後で合流する」

という“進め方”のことです。

- **同期（synchronous）**: Aを終えるまでBに進まない
- **非同期（async）**: Aの完了待ちの間にBも進める（Aが終わったら合流）

> 超重要：非同期は「同時に進める（並行）」であって、必ずしも「同時に実行（並列）」ではありません。

---

## 2. 同期 / 非同期 / 並行 / 並列 の違い

ここが混ざると全てが崩れます。まず言葉を固定します。

### 2.1 同期 vs 非同期（＝“待ち方”の違い）

- **同期**: 結果が返るまでその場で待つ（＝その間なにもできない）
- **非同期**: いったん別の仕事をし、結果が用意できたら受け取る（＝その間も動ける）

### 2.2 並行（Concurrency）vs 並列（Parallelism）（＝“実行のされ方”の違い）

- **並行**: 時間を切り替えながら“同時っぽく”進める（1CPUでも可能）
- **並列**: 本当に同時に実行する（複数CPUコア等が必要）

`asyncio` は主に **並行** を実現する仕組みです。

---

## 3. なぜ非同期が必要？（問題→解決）

### 3.1 問題：I/O待ちが“ムダ”になる

アプリはよく「待ち」が発生します。

- DB問い合わせ
- HTTPリクエスト
- ファイルI/O
- 外部API呼び出し

同期的に書くと「待っている間、CPUが暇」になります。

### 3.2 解決：待ってる間に他の仕事を進める

非同期だと、
- あるリクエストが DB 応答を待っている間
- 別のリクエスト処理を進められる

結果として、
- **同じCPUでも“さばける件数（スループット）”が増える**
- **待ち時間（レイテンシ）が改善することがある**

---

## 4. Pythonにおける非同期（`asyncio`）の中核概念

Pythonの非同期の中心は `asyncio`（イベントループ）です。

### 4.1 イベントループ（Event Loop）

- 非同期タスクを「いつ動かすか」を管理する司令塔
- 大事なのは **イベントループを止めない** こと

> ループが止まる = 全てが止まる

### 4.2 コルーチン（Coroutine）

- `async def` で定義した関数は **コルーチン**
- 呼び出しても即実行ではなく、**“途中で止まれる処理の設計図”**ができる

```python
async def f():
    await asyncio.sleep(1)

coro = f()     # ここではまだ動かない（コルーチンオブジェクト）
await coro     # ここで初めて実行される
```

### 4.3 Task（タスク）

- コルーチンをイベントループで「走らせる」ための実行単位

```python
t = asyncio.create_task(f())  # 背景で動き始める
await t                       # 結果を待つ（例外もここで出る）
```

> 重要：`create_task` しただけでは例外が見えにくい。
> **例外の回収（retrieve）**が運用品質を左右します。

---

## 5. 「await」＝“譲る”という発想

`await` は「待つ」というより、
> **いまのタスクの実行権をイベントループに返し、他のタスクを進めてもらう**

という意味です。

- `await` がある → 他タスクが動ける
- `await` がない重い処理 → ループが固まり、全体が止まる

この性質のため、非同期では
- **ブロッキングI/Oを避ける**
- CPU重い処理は **オフロード**（スレッド/プロセス）

が必要になります。

---

## 6. 非同期でよくある勘違い（重要）

### 勘違い1：非同期 = 速い
- 非同期は基本「I/O待ちのムダを減らす」
- CPU計算そのものを速くするわけではない

### 勘違い2：非同期 = 並列
- `asyncio` は多くの場合“並行”
- CPU並列はプロセス等が必要

### 勘違い3：`create_task` すれば勝手に安全
- タスク増殖でメモリが死ぬ
- 例外が回収されずに見落とす
- キャンセルやタイムアウト設計がないと“止められない”

---

## 7. 実務での典型パターン（ポーリング / ジョブ実行）

あなたが触っている構造は、実務で超頻出です。

### 7.1 典型：DBをポーリングし、ジョブを並行処理する

- ループで DB から未処理ジョブを取得
- ロックを取る
- `create_task` で処理を走らせる
- `Semaphore` で同時実行数を制限
- DBアクセス等の同期処理は `to_thread` でオフロード
- CPU重い処理は `ProcessPoolExecutor` でオフロード

> この設計の要点は「イベントループを止めない」ことと「バックプレッシャ（溜めすぎ防止）」です。

---

## 8. よくある落とし穴と対策（超概要）

ここは“概要だけ”。詳細は後続mdに分割するのが吉です。

### 8.1 タスクが増えすぎる（入力バースト）
- **対策**: `Semaphore`、`Queue`、タスク上限、バックプレッシャ

### 8.2 例外が見えない／回収できてない
- **対策**: `await` / `gather(return_exceptions=True)` / done-callback で `task.exception()` ログ

### 8.3 ハングして枠が返らず全停止
- **対策**: `asyncio.wait_for` でタイムアウト、watchdog

### 8.4 キャンセルに弱い（止められない）
- **対策**: `CancelledError` を握りつぶさない、shutdown設計

### 8.5 同期I/Oをイベントループで呼んで固まる
- **対策**: async対応ライブラリを使う or `to_thread` で逃がす

---

## 9. 次に読むべき分割ドキュメント案（構成案）

この「玄関」から、以下のように分割すると学びが速いです。

1. `async_with_sem.md` … `async with sem:`（Semaphoreの完全理解＋落とし穴）
2. `process_thread_offload_3patterns.md` … プロセス/スレッド/オフロード（3パターン解説）
3. `async_exception_handling.md` … 非同期の例外回収・キャンセル・タイムアウトの実戦テンプレ
4. `async_queue_worker_pattern.md` … `asyncio.Queue` によるワーカープールとバックプレッシャ
5. `async_design_checklist.md` … 常駐系（ポーリング）運用チェックリスト（監視・停止・再起動・ログ）

---

## 10. 最後に：この1枚で持ち帰るべき要点

- 非同期とは「待ってる間に別の処理を進め、後で合流する」こと
- `asyncio` の本質は **イベントループを止めない設計**
- `await` は「待つ」ではなく「譲る」
- `create_task` は便利だが、**例外回収・溜めすぎ・停止設計**がないと事故る

---

### 付録：最小の理解度チェック（3問）

1) `await` は何をしている？ “待つ”以外の表現で説明して。
2) `asyncio` の非同期は「並列」か「並行」か。理由も。
3) `create_task` したタスクの例外が見落とされるのはなぜ？回収方法を1つ挙げて。

---

この `非同期実行.md` を玄関にして、次は「例外処理」と「Queueワーカーパターン」を作ると、常駐ジョブ系の実装力が一段上がります。
